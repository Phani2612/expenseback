import { Expense_Model } from '../model/expense.model.js';
import { agenda } from '../agenda/agenda.js';
import { RecurringNotify } from '../utils/mailer.js';
import { User_Model } from '../model/User.model.js';

// Define Agenda job
agenda.define('check and add recurring expenses', async job => {
    const today = new Date();

    // Query only for the expenses that are due to be processed today
    const expenses = await Expense_Model.find({
        isActive: true,
        isAutoGenerated: { $ne: true },
        date: { $lte: today } // Only include expenses where the start date is today or in the past
    });

    for (const expense of expenses) {
        if (shouldAddExpenseToday(expense, today)) {
            const newExpense = new Expense_Model({
                ...expense.toObject(),
                _id: undefined,
                date: new Date(), // Set to current date for the new expense
                isActive: false,
                isAutoGenerated: true
            });

            await newExpense.save();

            expense.lastProcessedDate = new Date();
            await expense.save();
        } else {
            console.log('Expense skipped for today.');
        }
    }
});

function shouldAddExpenseToday(expense, today) {
    const startDate = new Date(expense.date);
    startDate.setHours(0, 0, 0, 0); // Normalize to midnight for comparison
    today.setHours(0, 0, 0, 0); // Normalize to midnight for comparison

    const lastProcessed = expense.lastProcessedDate ? new Date(expense.lastProcessedDate) : null;
    if (lastProcessed) {
        lastProcessed.setHours(0, 0, 0, 0); // Normalize to midnight for comparison
        if (lastProcessed.getTime() === today.getTime()) {
            return false; // Skip if already processed today
        }
    }

    switch (expense.frequency) {
        case 'daily':
            return true; // Always process daily expenses
        case 'weekly': {
            const diffInDays = Math.floor((today - startDate) / (1000 * 60 * 60 * 24));
            return diffInDays % 7 === 0; // Process every 7 days
        }
        case 'monthly':
            return today.getDate() === startDate.getDate(); // Process once a month on the same date
        case 'yearly':
            return today.getDate() === startDate.getDate() && today.getMonth() === startDate.getMonth(); // Process once a year on the same day/month
        default:
            return false;
    }
}

agenda.define('send recurring expense reminder', async job => {
    const expenses = await Expense_Model.find({ isActive: true, isAutoGenerated: { $ne: true } });

    // Get tomorrow's date
    const tomorrow = new Date();
    tomorrow.setDate(tomorrow.getDate() + 1);
    tomorrow.setHours(0, 0, 0, 0); // Set to midnight to only compare the date part

    // Loop through expenses and check if any are due tomorrow
    for (const expense of expenses) {
        const expenseDate = new Date(expense.date); // The start date of the recurring expense

        // Compare the expense recurrence to tomorrow's date based on its frequency
        if (shouldSendReminder(expenseDate, tomorrow, expense.frequency)) {
            // Get the user by user_id from the expense object
            const user = await User_Model.findById(expense.user_id);
            if (user && user.email) {
                // sendReminderEmail(); // Send reminder to user email
                RecurringNotify(user.email, user.username, expense);
            } else {
                console.log(`User with ID ${expense.user_id} not found or email is missing.`);
            }
        }
    }
});

function shouldSendReminder(expenseDate, reminderDate, frequency) {
    switch (frequency) {
        case 'Daily':
            return reminderDate >= expenseDate;
        case 'Weekly': {
            const diffInDays = Math.floor((reminderDate - expenseDate) / (1000 * 60 * 60 * 24));
            return diffInDays >= 0 && diffInDays % 7 === 0;
        }
        case 'Monthly':
            return reminderDate.getDate() === expenseDate.getDate() && reminderDate >= expenseDate;
        case 'Yearly':
            return reminderDate.getDate() === expenseDate.getDate() && reminderDate.getMonth() === expenseDate.getMonth() && reminderDate >= expenseDate;
        default:
            return false;
    }
}
